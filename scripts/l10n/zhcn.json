{
  "lang_name": "简体中文",
  "translators": "<li> <a href=\"https://github.com/lixiang810\" >lixiang810</a></li>",
  "ui_index_title": "Langsorter / 语言大评测",
  "ui_index_text": "<h2>Langsorter 是什么？</h2><p>Langsorter 本质上是一个心理学测验，它将通过向你提出问题来得出一个与你的心灵最贴合的编程语言。这个测试将基于流程图模型，根据你对这些问题的回答，把<span id='ideo_length'></span>种不同编程语言之一分配给你。也许你能贴合一些你自己知道的语言！</p><h2>我不明白其中一个问题！</h2><p>这个测验是一个心灵测验，如果你有什么不懂的，跟着你的感觉走就行了。</p><h2>我不喜欢我被匹配到的编程语言！</h2><p>¯\\_(ツ)_/¯</p>",
  "ui_index_start": "点击开始",
  "ui_index_tree": "查看结果树",
  "ui_index_contacts": "作者",
  "ui_index_contact_info": "<p><a href=\"https://github.com/is-cau/Langsorter\">GitHub 页面</a></p>",
  "ui_quiz_title": "语言大测评",
  "ui_quiz_back": "后退",
  "ui_results_title": "语言大测评",
  "ui_results_back": "返回首页",
  "ui_results_credits": "贡献者",
  "question_model": "如果你的面前有一个巨大到你可能难以解决的难题即将来临，你是选择动手强硬地快速解决，还是看着时机船到桥头自然直？",
  "question_type": "如果你的面前其实是一头怪兽，你是想用一击毙命但位置不能射错的弓箭杀死它，还是想用灵活但不那么锋利的短剑杀死他？",
  "question_mop": "你数学和物理两科的成绩哪个高？",
  "question_eot": "你更喜欢工程还是理论？",
  "question_coin": "你之前打死的怪兽掉落金币了，你希望得到一个花纹繁复的传统古硬币还是花纹简洁更现代的新硬币。",
  "question_mbti": "如果你的面前有一个你喜欢的蛋糕，请问它的上表面是自由随性比较凹凸不平的，还是规则统一具有平滑光泽的？",
  "question_fruit": "如果你的面前有一个很可口的水果，你希望它来自于丰饶的黄金国度，还是神秘的桃花源中？",
  "question_fxxklang": "如果你一定会遇到一个你可能无法解决的难题，你希望这个难题是人为设计的谜题，还是现实中存在的疑难杂症？",
  "question_puzzle": "你希望这个难题在难题的等级中有多难？（也就是说在它已经是难题的情况下）",
  "ideo_free_python": "非工程化的 Python",
  "ideo_free_python_desc": "Python 是一个命令式的语言。若你不对其使用工程化的手段，它用起来和弱类型语言没有什么差别。以上两点分别对应你之前选择的选项。<br>Python 是非常流行的语言，以方便简洁易用著称，适合多种人群，社区活跃！",
  "ideo_cpp": "C++",
  "ideo_cpp_desc": "被广泛使用的 C++ （与现代 C++ 不同）是一个命令式的语言。虽然其也有类型系统辅助验证程序是否正确，但通常一言难尽。历史“悠久”，语法传统。相较于 C 语言的“纯净感”， C++ 能混用多种编程范式，代码风格随使用者不同而不同（易读性也是）。以上四点分别对应你之前选择的选项。<br>如信息学竞赛和学长祖传代码等，是这种语言出没的重点地区。其知名度非常广，更多资料你可以搜索得到！",
  "ideo_new_cpp": "现代 C++",
  "ideo_new_cpp_desc": "现代 C++ 与传统 C++ 有很大的差别。虽然你可以使用函数式编程，但其仍然以命令式为主。现代 C++ 有较为完善的类型系统可用于验证程序是否正确。由于需要手动管理内存，它通常用于编写偏底层的系统级应用。以上三点分别对应你之前选择的选项。<br>现在有一个叫 Rust 的语言正在尝试与其竞争，具有一定函数式风格和略显奇特的语法，与你的性格说不定也合得来。不论如何，只要是学习这类语言，你可能都要经历一段略显陡峭的学习曲线。现代 C++ 也是一个热门话题，更多资料你可以搜索得到！",
  "ideo_c": "C",
  "ideo_c_desc": "C 语言是一个命令式的语言。相较于它一言难尽的类型系统，程序员的代码水平在保证程序的正确性方面更加重要。它的历史非常悠久，语法也很经典传统。直到现在，它的语法风格也较为统一，不会如 C++ 一般出现各种奇葩的编程范式。以上四点分别对应你之前选择的选项。<br>其知名度非常广，更多资料你可以搜索得到！",
  "ideo_java": "Java",
  "ideo_java_desc": "Java 是一个命令式语言（不是不能写函数式代码，只是 Java 社区中的大多数人都认为 Java 的函数式不能用得太广，否则晦涩难懂）。 Java 同时还是比较严格的面向对象语言，意味着他的类型系统存在感很强，约束你的程序。它虽然发明是为了嵌入式等场景，但目前最广泛被应用的地方是网络工程，如网站和游戏的后端等，不论如何，它并不是一个很底层的语言。同一些新兴的语言相比，它的历史也较长，语法等方面唯美传统。以上四点分别对应你之前选择的选项。<br>其知名度非常广，更多资料你可以搜索得到！",
  "ideo_js": "JavaScript",
  "ideo_js_desc": "JS 是一个命令式和函数式兼有的语言，比较灵活。同时，与 TypeScript 不同，纯的 JS 是一个超级弱类型语言，各种有关 JS 类型系统的笑话满天飞，不过这也意味着如果你对自己的水平很自信的话， JS 能被你写得自由自在、无拘无束。虽然其被发明于互联网刚兴起时，但直到现在仍保持每年都更新，越来越现代。不论你写的是哪种环境的 JS ，你一份代码的整体风格都基本是统一的。以上四点分别对应你之前选择的选项。<br>其知名度非常广，更多资料你可以搜索得到！",
  "ideo_ts": "TypeScript",
  "ideo_ts_desc": "TypeScript 是 JavaScript 的改进版，这意味着 JS 所具有的命令式与函数式兼可使用、比较灵活的特点，在 TS 身上也都有。 TS 对 JS 的改进主要在提供了一个类型检查工具 <code>tsc</code> ，这意味着你可以选择被限制编写过于奔放、无视静态检查的代码，而写出准确、相对安全的代码。同其他范式灵活、强类型的语言相比， TS 是非常年轻、新潮的选择。如果你了解过 Rust ，它与 TS 在这些方面都很相似，除了—— Rust 更加底层，而 TS 某些程度更加抽象。以上四点分别对应你之前选择的选项。<br>如果你想要学习网络前端，设计网页、小程序等，越早与 TS 交朋友越好。如果你不喜欢前端，却得到了这个结果，你也可以试着了解用 TS 编写如 npm 包或命令行工具等与前端无关的东西。本身大多数人对 TS 的评价就是“编写很爽”，你也可以尝试一下，希望能在其中得到快乐。",
  "ideo_go": "go",
  "ideo_go_desc": "go 语言包括其整体社区的风格都是非常朴实、偏向工程的，所以他和 C 语言一样更偏向命令式语言，像函数式这种过于学术气息的风味在它的身上基本找不到。为了工程开发时得到高质量、易读且准确的代码，它同时还是一个强类型语言，使用类型系统约束程序。为了工程开发的速度更快，错误更少，它也不需要你手动管理内存，而是把很多相关细节抽象起来，使你远离底层的约束。类似（但也不是很类似）定位的语言还有比较广为人知的 Java ，但 go 语言更加年轻，也更有活力。以上四点分别对应你之前选择的选项。<br>go 语言目前主要的舞台是网络工程中的后端，据说 bilibili 的网站服务器就是使用 go 语言编写的。网络后端生态位主要就是 go 、 Java 和 php 三种语言，而 php 的工程性太弱， Java 太老，所以从这个方面来看， go 语言还是具有比较美好的前景的。",
  "ideo_sql": "SQL",
  "ideo_sql_desc": "SQL 是一种关系型数据库（也就是类似 Excel 那样数据一条一条的数据库）的查询语言，但它提供的功能过多，以至于你可以洋洋洒洒地写下几页 SQL 代码来代替网络后端",
  "ideo_vb": "Visual Basic",
  "ideo_vb_desc": "vb",
  "ideo_fortran": "Fortran",
  "ideo_fortran_desc": "fortran",
  "ideo_asm": "asm",
  "ideo_asm_desc": "asm",
  "ideo_php": "php",
  "ideo_php_desc": "php",
  "ideo_rust": "Rust",
  "ideo_rust_desc": "rust",
  "ideo_ruby": "Ruby",
  "ideo_ruby_desc": "ruby",
  "ideo_kotlin": "Kotlin",
  "ideo_kotlin_desc": "kotlin",
  "ideo_prolog": "Prolog",
  "ideo_prolog_desc": "prolog",
  "ideo_verilog": "Verilog",
  "ideo_verilog_desc": "verilog",
  "ideo_haskell": "Haskell",
  "ideo_haskell_desc": "haskell",
  "ideo_commmon lisp": "Commmon Lisp",
  "ideo_commmon _desclisp": "commmon lisp",
  "ideo_elisp": "Elisp",
  "ideo_elisp_desc": "elisp",
  "ideo_lua": "Lua",
  "ideo_lua_desc": "lua",
  "ideo_ocaml": "OCaml",
  "ideo_ocaml_desc": "ocaml",
  "ideo_bash": "bash",
  "ideo_bash_desc": "bash 和 sh 等",
  "ideo_zig": "Zig",
  "ideo_zig_desc": "zig",
  "btn_former": "前者",
  "btn_latter": "后者",
  "btn_harder": "不，还不够难",
  "btn_both": "看情况",
  "btn_easy": "简单",
  "btn_medium": "中等",
  "btn_hard": "困难"
}
